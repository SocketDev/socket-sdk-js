#!/bin/bash
# Socket Security Pre-push Hook
# MANDATORY ENFORCEMENT LAYER - Cannot be bypassed with --no-verify.
# Validates all commits being pushed for security issues and AI attribution.

set -e

# Colors for output.
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m'

echo "${GREEN}Running mandatory pre-push validation...${NC}"

# Allowed public API key (used in socket-lib).
ALLOWED_PUBLIC_KEY="sktsec_t_--RAN5U4ivauy4w37-6aoKyYPDt5ZbaT5JBVMqiwKo_api"

# Get the remote name and URL.
remote="$1"
url="$2"

TOTAL_ERRORS=0

# Read stdin for refs being pushed.
while read local_ref local_sha remote_ref remote_sha; do
  # Get the range of commits being pushed.
  if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
    # New branch - check all commits.
    range="$local_sha"
  else
    # Existing branch - check new commits.
    range="$remote_sha..$local_sha"
  fi

  ERRORS=0

  # ============================================================================
  # CHECK 1: Scan commit messages for AI attribution
  # ============================================================================
  echo "Checking commit messages for AI attribution..."

  # Check each commit in the range for AI patterns.
  while IFS= read -r commit_sha; do
    full_msg=$(git log -1 --format='%B' "$commit_sha")

    if echo "$full_msg" | grep -qiE "(Generated with|Co-Authored-By: Claude|Co-Authored-By: AI|ðŸ¤– Generated|AI generated|Claude Code|@anthropic|Assistant:|Generated by Claude|Machine generated)"; then
      if [ $ERRORS -eq 0 ]; then
        echo "${RED}âœ— BLOCKED: AI attribution found in commit messages!${NC}"
        echo "Commits with AI attribution:"
      fi
      echo "  - $(git log -1 --oneline "$commit_sha")"
      ERRORS=$((ERRORS + 1))
    fi
  done < <(git rev-list "$range")

  if [ $ERRORS -gt 0 ]; then
    echo ""
    echo "These commits were likely created with --no-verify, bypassing the"
    echo "commit-msg hook that strips AI attribution."
    echo ""
    echo "To fix:"
    echo "  git rebase -i $remote_sha"
    echo "  Mark commits as 'reword', remove AI attribution, save"
    echo "  git push"
  fi

  # ============================================================================
  # CHECK 2: File content security checks
  # ============================================================================
  echo "Checking files for security issues..."

  # Get all files changed in these commits.
  CHANGED_FILES=$(git diff --name-only "$range" 2>/dev/null || echo "")

  if [ -n "$CHANGED_FILES" ]; then
    # Check for sensitive files.
    if echo "$CHANGED_FILES" | grep -qE '^\.env(\.local)?$'; then
      echo "${RED}âœ— BLOCKED: Attempting to push .env file!${NC}"
      echo "Files: $(echo "$CHANGED_FILES" | grep -E '^\.env(\.local)?$')"
      ERRORS=$((ERRORS + 1))
    fi

    # Check for .DS_Store.
    if echo "$CHANGED_FILES" | grep -q '\.DS_Store'; then
      echo "${RED}âœ— BLOCKED: .DS_Store file in push!${NC}"
      echo "Files: $(echo "$CHANGED_FILES" | grep '\.DS_Store')"
      ERRORS=$((ERRORS + 1))
    fi

    # Check for log files.
    if echo "$CHANGED_FILES" | grep -E '\.log$' | grep -v 'test.*\.log' | grep -q .; then
      echo "${RED}âœ— BLOCKED: Log file in push!${NC}"
      echo "Files: $(echo "$CHANGED_FILES" | grep -E '\.log$' | grep -v 'test.*\.log')"
      ERRORS=$((ERRORS + 1))
    fi

    # Check file contents for secrets.
    for file in $CHANGED_FILES; do
      if [ -f "$file" ] && [ ! -d "$file" ]; then
        # Skip test files, example files, and hook scripts.
        if echo "$file" | grep -qE '\.(test|spec)\.(m?[jt]s|tsx?)$|\.example$|/test/|/tests/|fixtures/|\.git-hooks/|\.husky/'; then
          continue
        fi

        # Check for hardcoded user paths.
        if grep -E '(/Users/[^/\s]+/|/home/[^/\s]+/|C:\\Users\\[^\\]+\\)' "$file" 2>/dev/null | grep -q .; then
          echo "${RED}âœ— BLOCKED: Hardcoded personal path found in: $file${NC}"
          grep -n -E '(/Users/[^/\s]+/|/home/[^/\s]+/|C:\\Users\\[^\\]+\\)' "$file" | head -3
          ERRORS=$((ERRORS + 1))
        fi

        # Check for Socket API keys.
        if grep -E 'sktsec_[a-zA-Z0-9_-]+' "$file" 2>/dev/null | grep -v "$ALLOWED_PUBLIC_KEY" | grep -v 'your_api_key_here' | grep -v 'SOCKET_SECURITY_API_KEY=' | grep -v 'fake-token' | grep -v 'test-token' | grep -q .; then
          echo "${RED}âœ— BLOCKED: Real API key detected in: $file${NC}"
          grep -n 'sktsec_' "$file" | grep -v "$ALLOWED_PUBLIC_KEY" | grep -v 'your_api_key_here' | grep -v 'fake-token' | grep -v 'test-token' | head -3
          ERRORS=$((ERRORS + 1))
        fi

        # Check for AWS keys.
        if grep -iE '(aws_access_key|aws_secret|AKIA[0-9A-Z]{16})' "$file" 2>/dev/null | grep -q .; then
          echo "${RED}âœ— BLOCKED: Potential AWS credentials found in: $file${NC}"
          grep -n -iE '(aws_access_key|aws_secret|AKIA[0-9A-Z]{16})' "$file" | head -3
          ERRORS=$((ERRORS + 1))
        fi

        # Check for GitHub tokens.
        if grep -E 'gh[ps]_[a-zA-Z0-9]{36}' "$file" 2>/dev/null | grep -q .; then
          echo "${RED}âœ— BLOCKED: Potential GitHub token found in: $file${NC}"
          grep -n -E 'gh[ps]_[a-zA-Z0-9]{36}' "$file" | head -3
          ERRORS=$((ERRORS + 1))
        fi

        # Check for private keys.
        if grep -E '-----BEGIN (RSA |EC |DSA )?PRIVATE KEY-----' "$file" 2>/dev/null | grep -q .; then
          echo "${RED}âœ— BLOCKED: Private key found in: $file${NC}"
          ERRORS=$((ERRORS + 1))
        fi
      fi
    done
  fi

  TOTAL_ERRORS=$((TOTAL_ERRORS + ERRORS))
done

if [ $TOTAL_ERRORS -gt 0 ]; then
  echo ""
  echo "${RED}âœ— Push blocked by mandatory validation!${NC}"
  echo "Fix the issues above before pushing."
  exit 1
fi

echo "${GREEN}âœ“ All mandatory validation passed!${NC}"
exit 0
